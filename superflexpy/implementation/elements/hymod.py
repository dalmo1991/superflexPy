"""
Copyright 2020 Marco Dal Molin et al.

This file is part of SuperflexPy.

SuperflexPy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SuperflexPy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with SuperflexPy. If not, see <https://www.gnu.org/licenses/>.

This file is part of the SuperflexPy modelling framework. For details about it,
visit the page https://superflexpy.readthedocs.io

CODED BY: Marco Dal Molin
DESIGNED BY: Marco Dal Molin, Fabrizio Fenicia, Dmitri Kavetski

This file contains the implementation of some elements needed to replicate the
model Hymod (Boyle et al., 2001; Wagner et al., 2001).

Note that the elemented implemented here are extremely similar to the ones
used in the HBV implementation.

Bibliography
------------

Boyle, D. P. (2001). Multicriteria calibration of hydrologic models, The
University of Arizona. http://hdl.handle.net/10150/290657

Wagener, T., Boyle, D. P., Lees, M. J., Wheater, H. S., Gupta, H. V., and
Sorooshian, S.: A framework for development and application of hydrological
models, Hydrol. Earth Syst. Sci., 5, 13â€“26,
https://doi.org/10.5194/hess-5-13-2001, 2001.
"""


import numba as nb

from ...framework.element import ODEsElement


class UpperZone(ODEsElement):
    """
    This class implements the UpperZone reservoir of Hymod. Note that the
    evaporation equation has been smoothed.
    """

    def __init__(self, parameters, states, approximation, id):
        """
        This is the initializer of the class UnsaturatedReservoir.

        Parameters
        ----------
        parameters : dict
            Parameters of the element. The keys must be:
            'Smax' : maximum reservoir storage
            'm' : Smoothing factor for evapotranspiration
            'beta' : Exponent in the relation for the streamflow
        states : dict
            Initial state of the element. The keys must be:
            - 'S0' : initial storage of the reservoir.
        approximation : superflexpy.utils.numerical_approximation.NumericalApproximator
            Numerial method used to approximate the differential equation
        id : str
            Itentifier of the element. All the elements of the framework must
            have an id.
        """

        ODEsElement.__init__(self, parameters=parameters, states=states, approximation=approximation, id=id)

        self._fluxes_python = [self._fluxes_function_python]

        if approximation.architecture == "numba":
            self._fluxes = [self._fluxes_function_numba]
        elif approximation.architecture == "python":
            self._fluxes = [self._fluxes_function_python]

    def set_input(self, input):
        """
        Set the input of the element.

        Parameters
        ----------
        input : list(numpy.ndarray)
            List containing the input fluxes of the element. It contains 2
            fluxes:
            1. Rainfall
            2. PET
        """

        self.input = {"P": input[0], "PET": input[1]}

    def get_output(self, solve=True):
        """
        This method solves the differential equation governing the routing
        store.

        Returns
        -------
        list(numpy.ndarray)
            Output fluxes in the following order:
            1. Streamflow (Q)
        """

        if solve:
            self._solver_states = [self._states[self._prefix_states + "S0"]]

            self._solve_differential_equation()

            # Update the state
            self.set_states({self._prefix_states + "S0": self.state_array[-1, 0]})

        fluxes = self._num_app.get_fluxes(
            fluxes=self._fluxes_python,
            S=self.state_array,
            S0=self._solver_states,
            dt=self._dt,
            **self.input,
            **{k[len(self._prefix_parameters) :]: self._parameters[k] for k in self._parameters},
        )

        return [-fluxes[0][2]]

    def get_AET(self):
        """
        This method calculates the actual evapotranspiration

        Returns
        -------
        numpy.ndarray
            Array of actual evapotranspiration
        """

        try:
            S = self.state_array
        except AttributeError:
            message = "{}get_aet method has to be run after running ".format(self._error_message)
            message += "the model using the method get_output"
            raise AttributeError(message)

        fluxes = self._num_app.get_fluxes(
            fluxes=self._fluxes_python,
            S=S,
            S0=self._solver_states,
            dt=self._dt,
            **self.input,
            **{k[len(self._prefix_parameters) :]: self._parameters[k] for k in self._parameters},
        )

        return [-fluxes[0][1]]

    # PROTECTED METHODS

    @staticmethod
    def _fluxes_function_python(S, S0, ind, P, Smax, m, beta, PET, dt):
        # TODO: handle time variable parameters (Smax) -> overflow

        if ind is None:
            return (
                [
                    P,
                    -PET * ((S / Smax) * (1 + m)) / ((S / Smax) + m),
                    -P * (1 - (1 - (S / Smax)) ** beta),
                ],
                0.0,
                S0 + P * dt,
            )
        else:
            return (
                [
                    P[ind],
                    -PET[ind] * ((S / Smax[ind]) * (1 + m[ind])) / ((S / Smax[ind]) + m[ind]),
                    -P[ind] * (1 - (1 - (S / Smax[ind])) ** beta[ind]),
                ],
                0.0,
                S0 + P[ind] * dt[ind],
                [
                    0.0,
                    -PET[ind] * m[ind] * Smax[ind] * (1 + m[ind]) / ((S + Smax[ind] * m[ind]) ** 2),
                    -P[ind] * beta[ind] * ((1 - (S / Smax[ind])) ** (beta[ind] - 1)) / Smax[ind],
                ],
            )

    @staticmethod
    @nb.jit(
        "Tuple((UniTuple(f8, 3), f8, f8, UniTuple(f8, 3)))"
        "(optional(f8), f8, i4, f8[:], f8[:], f8[:], f8[:], f8[:], f8[:])",
        nopython=True,
    )
    def _fluxes_function_numba(S, S0, ind, P, Smax, m, beta, PET, dt):
        # TODO: handle time variable parameters (Smax) -> overflow

        return (
            (
                P[ind],
                -PET[ind] * ((S / Smax[ind]) * (1 + m[ind])) / ((S / Smax[ind]) + m[ind]),
                -P[ind] * (1 - (1 - (S / Smax[ind])) ** beta[ind]),
            ),
            0.0,
            S0 + P[ind] * dt[ind],
            (
                0.0,
                -PET[ind] * m[ind] * Smax[ind] * (1 + m[ind]) / ((S + Smax[ind] * m[ind]) ** 2),
                -P[ind] * beta[ind] * ((1 - (S / Smax[ind])) ** (beta[ind] - 1)) / Smax[ind],
            ),
        )


class LinearReservoir(ODEsElement):
    """
    This class implements the linear reservoirs present in the channel routing
    and in the lower zone of Hymod.
    """

    def __init__(self, parameters, states, approximation, id):
        """
        This is the initializer of the class PowerReservoir.

        Parameters
        ----------
        parameters : dict
            Parameters of the element. The keys must be:
            - 'k' : multiplier of the state
        states : dict
            Initial state of the element. The keys must be:
            - 'S0' : initial storage of the reservoir.
        approximation : superflexpy.utils.numerical_approximation.NumericalApproximator
            Numerial method used to approximate the differential equation
        id : str
            Itentifier of the element. All the elements of the framework must
            have an id.
        """

        ODEsElement.__init__(self, parameters=parameters, states=states, approximation=approximation, id=id)

        self._fluxes_python = [self._fluxes_function_python]  # Used by get fluxes, regardless of the architecture

        if approximation.architecture == "numba":
            self._fluxes = [self._fluxes_function_numba]
        elif approximation.architecture == "python":
            self._fluxes = [self._fluxes_function_python]

    # METHODS FOR THE USER

    def set_input(self, input):
        """
        Set the input of the element.

        Parameters
        ----------
        input : list(numpy.ndarray)
            List containing the input fluxes of the element. It contains 1
            flux:
            1. Rainfall
        """

        self.input = {"P": input[0]}

    def get_output(self, solve=True):
        """
        This method solves the differential equation governing the routing
        store.

        Returns
        -------
        list(numpy.ndarray)
            Output fluxes in the following order:
            1. Streamflow (Q)
        """

        if solve:
            self._solver_states = [self._states[self._prefix_states + "S0"]]
            self._solve_differential_equation()

            # Update the state
            self.set_states({self._prefix_states + "S0": self.state_array[-1, 0]})

        fluxes = self._num_app.get_fluxes(
            fluxes=self._fluxes_python,  # I can use the python method since it is fast
            S=self.state_array,
            S0=self._solver_states,
            dt=self._dt,
            **self.input,
            **{k[len(self._prefix_parameters) :]: self._parameters[k] for k in self._parameters},
        )

        return [-fluxes[0][1]]

    # PROTECTED METHODS

    @staticmethod
    def _fluxes_function_python(S, S0, ind, P, k, dt):
        if ind is None:
            return (
                [
                    P,
                    -k * S,
                ],
                0.0,
                S0 + P * dt,
            )
        else:
            return (
                [
                    P[ind],
                    -k[ind] * S,
                ],
                0.0,
                S0 + P[ind] * dt[ind],
                [0.0, -k[ind]],
            )

    @staticmethod
    @nb.jit(
        "Tuple((UniTuple(f8, 2), f8, f8, UniTuple(f8, 2)))(optional(f8), f8, i4, f8[:], f8[:], f8[:])", nopython=True
    )
    def _fluxes_function_numba(S, S0, ind, P, k, dt):
        # This method is used only when solving the equation

        return (
            (
                P[ind],
                -k[ind] * S,
            ),
            0.0,
            S0 + P[ind] * dt[ind],
            (0.0, -k[ind]),
        )
